
=======================================================================
Pour modifier les options logo_white et logo_dark, vous pouvez ajouter des
 inputs de type "file" pour permettre à l'utilisateur de télécharger de 
 nouvelles images de logo.

Voici un exemple de code qui montre comment modifier les options logo_white
 et logo_dark :

// Next.js 14 avec TypeScript
import { useState, useEffect } from 'react';

interface Option {
  id: number;
  name: string;
  value: string;
}

const [options, setOptions] = useState<Option[]>([]);
const [logoWhite, setLogoWhite] = useState<File | null>(null);
const [logoDark, setLogoDark] = useState<File | null>(null);

const fetchOptions = async () => {
  const response = await fetch('/api/options');
  const data = await response.json();
  setOptions(data);
};

const handleUpdateOption = async (option: Option) => {
  const response = await fetch(`/api/options/${(link unavailable)}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(option),
  });
  const data = await response.json();
  setOptions(options.map((opt) => (link unavailable) === (link unavailable) ? data : opt));
};

const handleUpdateLogo = async (logo: File, optionName: string) => {
  const formData = new FormData();
  formData.append('logo', logo);
  const response = await fetch(`/api/options/${optionName}`, {
    method: 'PUT',
    body: formData,
  });
  const data = await response.json();
  setOptions(options.map((opt) => opt.name === optionName ? data : opt));
};

useEffect(() => {
  fetchOptions();
}, []);

return (
  <div>
    <h1>Options</h1>
    <form>
      {/* ... */}
      <div>
        <label>Logo White</label>
        <input
          type="file"
          onChange={(event) => {
            setLogoWhite(event.target.files[0]);
            handleUpdateLogo(event.target.files[0], 'logo_white');
          }}
        />
        {logoWhite && <img src={URL.createObjectURL(logoWhite)} alt="Logo White" />}
      </div>
      <div>
        <label>Logo Dark</label>
        <input
          type="file"
          onChange={(event) => {
            setLogoDark(event.target.files[0]);
            handleUpdateLogo(event.target.files[0], 'logo_dark');
          }}
        />
        {logoDark && <img src={URL.createObjectURL(logoDark)} alt="Logo Dark" />}
      </div>
    </form>
  </div>
);



// Laravel API
use Illuminate\Http\Request;
use App\Models\Option;

Route::get('/api/options', function (Request $request) {
    $options = Option::all();
    return response()->json($options);
});

Route::put('/api/options/{name}', function (Request $request, $name) {
    $option = Option::where('name', $name)->first();
    if ($request->hasFile('logo')) {
        $logo = $request->file('logo');
        $option->value = $logo->store('logos', 'public');
    }
    $option->save();
    return response()->json($option);
});

Dans cet exemple, nous utilisons la fonction handleUpdateLogo pour mettre à
 jour les logos lorsque l'utilisateur télécharge de nouvelles images. Nous 
 utilisons également la fonction URL.createObjectURL pour afficher les images
  téléchargées.


====================================================

Je m'excuse si mon explication était trop compliquée !

En résumé, NextAuth ne crypte pas automatiquement le token d'accès avant de le stocker dans la session. Il est donc important de crypter le token avant de le stocker pour éviter les accès non autorisés.

Pour crypter le token, vous pouvez utiliser une fonction de cryptage simple, comme par exemple :

const crypterToken = (token) => {
  return token + 'votre_clé_de_cryptage';
};

Et pour décrypter le token, vous pouvez utiliser une fonction de décryptage simple, comme par exemple :

const décrypterToken = (token) => {
  return token.replace('votre_clé_de_cryptage', '');
};

Il est important de remplacer 'votre_clé_de_cryptage' par une clé de cryptage sécurisée.

Ensuite, vous pouvez utiliser ces fonctions pour crypter et décrypter le token d'accès avant de le stocker dans la session.